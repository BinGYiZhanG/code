### 思路
* 一开始要把分店坐标都压入队列，标记分店位置，记录步数，计算成本


```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <queue>

using namespace std;

const int inf=0x3f3f3f3f;

struct Node{
    int x,y;
}tmp;

int n,m,k,d;
///n:方格图的大小
///m:东东的分店数量
///k:客户的数量
///d:不能经过的点的数量

int dx[4]={1,-1,0,0};
int dy[4]={0,0,1,-1};
bool vis[1010][1010];

int mp[1010][1010];
int bushu[1010][1010];
///0:客户位置
///1:分店位置
///2:不可达位置
int num[1010][1010];
///记录该客户所需用餐量()

int main(){
    scanf("%d%d%d%d",&n,&m,&k,&d);
    int tmpx,tmpy,numc,kuhunum=0;
    queue<Node> que;
    for(int i=0;i<m;i++){///分店号
        scanf("%d%d",&tmp.x,&tmp.y);
        bushu[tmp.x][tmp.y]=0;
        que.push(tmp);
    }
    for(int i=0;i<k;i++){
        scanf("%d%d%d",&tmpx,&tmpy,&numc);
        num[tmpx][tmpy]=numc;
        mp[tmpx][tmpy]=3;///客户位置,不能置为0，因为二维数组初始化就是0
        kuhunum++;
    }
    for(int i=0;i<d;i++){
        scanf("%d%d",&tmp.x,&tmp.y);
        mp[tmp.x][tmp.y]=2;///不可达
    }
    int ansum=0;///记录花费成本
    bool flag=false;
    Node nd;
    while(!que.empty()){
        tmp=que.front();    que.pop();

        for(int i=0;i<4;i++){
            nd.x=tmp.x+dx[i];
            nd.y=tmp.y+dy[i];
            if(nd.x>n||nd.x<1||nd.y>n||nd.y<1||mp[nd.x][nd.y]==2||bushu[nd.x][nd.y]!=0)
                continue;
            bushu[nd.x][nd.y]=bushu[tmp.x][tmp.y]+1;
            que.push(nd);
            if(mp[nd.x][nd.y]==3){
                ansum+=num[nd.x][nd.y]*bushu[nd.x][nd.y];
                ///cout<<"用餐量,步数:"<<num[nd.x][nd.y]<<","<<bushu[nd.x][nd.y]<<endl;
                kuhunum--;
                if(kuhunum==0){
                    flag=true;
                    break;
                }
            }
        }
        if(flag)
            break;
    }
    printf("%d\n",ansum);

    return 0;
}


```









* 30分代码

```


/*
30分思路:按照分店,把每个客户给遍历了
vector<node> fendian,jinzhi;///东东的分店数
vector<Node> kehu;

bool JinZhi(int x,int y){
    for(int i=0;i<d;i++)
        if(jinzhi[i].x==x&&jinzhi[i].y==y)
            return true;
    return false;
}

int bfs(){

    int res=0;

    ///对每个客户点进行bfs,求最短距离
    for(int i=0;i<k;i++){
        ///目的地：kehu[i].x,kehu[i].y

        int mindis=inf;///计算最小距离

        for(int j=0;j<m;j++){///从每个分店出发，寻找最短距离
            queue<node> q;
            memset(vis,false,sizeof(vis));
            int ans=0;
            fendian[j].step=0;
            q.push(fendian[j]);

            while(!q.empty()){
                node top=q.front();
                q.pop();

                if(top.x==kehu[i].x&&top.y==kehu[i].y){
                    ans=top.step;
                    break;
                }

                for(int k=0;k<4;k++){
                    int nx=top.x+dx[k];
                    int ny=top.y+dy[k];
                    if(nx<1||nx>n||ny<1||ny>n||vis[nx][ny]||JinZhi(nx,ny))///越界
                        continue;
                    vis[nx][ny]=true;///置访问过

                    node cur;
                    cur.x=nx;
                    cur.y=ny;
                    cur.step=top.step+1;
                    q.push(cur);
                }
            }
            mindis=min(mindis,ans);
        }
        //printf("第%d个客户点的最短距离:%d,费用:%d\n",i,mindis,mindis*kehu[i].num);
        res+=mindis*kehu[i].num;
    }
    return res;
}

int main()
{
    cin>>n>>m>>k>>d;
    fendian.resize(m+1);
    jinzhi.resize(d+1);
    kehu.resize(k+1);
    for(int i=0;i<m;i++)
        cin>>fendian[i].x>>fendian[i].y;

    for(int i=0;i<k;i++)
        cin>>kehu[i].x>>kehu[i].y>>kehu[i].num;

    for(int i=0;i<d;i++)
        cin>>jinzhi[i].x>>jinzhi[i].y;

    int ans=bfs();
    cout<<ans<<endl;

    return 0;
}
*/


```


