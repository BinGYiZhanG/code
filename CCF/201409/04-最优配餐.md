### 思路
* 一开始要把分店坐标都压入队列，标记分店位置，记录步数，计算成本


```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <queue>

using namespace std;

const int inf=0x3f3f3f3f;

struct Node{
    int x,y;
}tmp;

int n,m,k,d;
///n:方格图的大小
///m:东东的分店数量
///k:客户的数量
///d:不能经过的点的数量

int dx[4]={1,-1,0,0};
int dy[4]={0,0,1,-1};
bool vis[1010][1010];

int mp[1010][1010];
int bushu[1010][1010];
///0:客户位置
///1:分店位置
///2:不可达位置
int num[1010][1010];
///记录该客户所需用餐量()

int main(){
    scanf("%d%d%d%d",&n,&m,&k,&d);
    int tmpx,tmpy,numc,kuhunum=0;
    queue<Node> que;
    for(int i=0;i<m;i++){///分店号
        scanf("%d%d",&tmp.x,&tmp.y);
        bushu[tmp.x][tmp.y]=0;
        que.push(tmp);
    }
    for(int i=0;i<k;i++){
        scanf("%d%d%d",&tmpx,&tmpy,&numc);
        num[tmpx][tmpy]=numc;
        mp[tmpx][tmpy]=3;///客户位置,不能置为0，因为二维数组初始化就是0
        kuhunum++;
    }
    for(int i=0;i<d;i++){
        scanf("%d%d",&tmp.x,&tmp.y);
        mp[tmp.x][tmp.y]=2;///不可达
    }
    int ansum=0;///记录花费成本
    bool flag=false;
    Node nd;
    while(!que.empty()){
        tmp=que.front();    que.pop();

        for(int i=0;i<4;i++){
            nd.x=tmp.x+dx[i];
            nd.y=tmp.y+dy[i];
            if(nd.x>n||nd.x<1||nd.y>n||nd.y<1||mp[nd.x][nd.y]==2||bushu[nd.x][nd.y]!=0)
                continue;
            bushu[nd.x][nd.y]=bushu[tmp.x][tmp.y]+1;
            que.push(nd);
            if(mp[nd.x][nd.y]==3){
                ansum+=num[nd.x][nd.y]*bushu[nd.x][nd.y];
                ///cout<<"用餐量,步数:"<<num[nd.x][nd.y]<<","<<bushu[nd.x][nd.y]<<endl;
                kuhunum--;
                if(kuhunum==0){
                    flag=true;
                    break;
                }
            }
        }
        if(flag)
            break;
    }
    printf("%d\n",ansum);

    return 0;
}


```
