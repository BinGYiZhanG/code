
* 测试数据
```
11 5
html
..head
....title
..body
....h1
....p #subtitle
....div #main
......h2
......p #one
......div
........p #two
p
#subtitle
h3
div p
div div p

```


* ```AC代码```

```
#include <bits/stdc++.h>

using namespace std;

const int maxn=105;

struct Node{
    string label,id;///标签,id
    int cnt;
}a[maxn];

int n,m;
string s;

void mystrlwr(string &s){
    for(int i=0;i<(int)s.size();i++)
        s[i]=tolower(s[i]);
}

///在数组a中[1,st](也就是1到st行)寻找缩进小于cnt,且标签或属性等于s的元素
bool search(int &st,int &cnt,string s){
    for(int i=st;i>=1;i--)///往上找父节点
        if(a[i].cnt<cnt){///遍历，说明是要查询的符结点
            ///查询成功
			cnt=a[i].cnt,st=i;///保证a[i]是它的父亲，即第一个缩进小于它的元素
			if(s==a[i].label||s==a[i].id) return true;//成功
        }
    return false;///查询失败
}

int main(){
    scanf("%d%d",&n,&m);
    getchar();
    for(int i=1;i<=n;i++){
        getline(cin,s);
        int cnt=0,pos1=-1,pos2=-1;
        ///cnt记录.数量,pos1记录第一个标签位置,pos2记录是否有'#',即id
        int len=s.size();
        for(int j=0;j<len;j++){
            if(s[j]=='.')
                cnt++;
            else if(pos1==-1&&s[j]!='.')
                pos1=j;
            else if(s[j]=='#')
                pos2=j;
        }
        a[i].cnt=cnt;
        if(pos2==-1){///如果不存在id
            a[i].label=s.substr(pos1);
            a[i].id="";
        }else{
            a[i].label=s.substr(pos1,pos2-pos1-1);
            a[i].id=s.substr(pos2);///不去掉'#'目的:为了标识是id
        }
        mystrlwr(a[i].label);///因为标签大小写不敏感,所以把标签转为小写
        //cout<<"cnt:"<<a[i].cnt<<";label:"<<a[i].label<<";id:"<<a[i].id<<endl;
    }

    for(int i=0;i<m;i++){
        char tmp[100];
        vector<string> query;
        vector<int> ans;
        gets(tmp);
        char *sp=strtok(tmp," ");///分割查询
        while(sp){
            query.push_back(sp);
            sp=strtok(NULL," ");
        }
        int len=query.size();
        for(int j=0;j<len;j++)///将标签统一化成小写
            if(query[j][0]!='#')    mystrlwr(query[j]);

        for(int j=1;j<=n;j++){///匹配n行
            //如果查询的最后一个元素与列相匹配,则继续匹配
            if(query[len-1]==a[j].label||query[len-1]==a[j].id){
        ///st是从哪一行开始遍历查询，cnt为缩进数,查询的元素有多少个，
        ///div div p 这个输入，len=3,
        ///为什么不是-1,因为-1得到的是最后一个要找的内容(第一个if已经匹配)，-2则是倒数第二个内容
                int st=j,cnt=a[j].cnt,k=len-2;///如果存在嵌套，匹配上级,
        ///为什么不是-1,因为-1得到的是最后一个要找的内容(第一个if已经匹配)，-2则是倒数第二个内容
                for(;k>=0;k--)///如果存在嵌套，匹配上级,
                    if(!search(st,cnt,query[k]))    break;
        ///k<0 ，的条件，一，是要寻找的标签只有1个，直接匹配，
        ///二，要寻找的标签有2个或以上，for循环向上匹配，
        ///如果一开始k<0，说明查询只有一个id或者label，因为在最外层已经匹配，所以直接推入匹配标号即可
                if(k<0)
                    ans.push_back(j);
            }
        }

        //输出结果
        cout<<ans.size();
        for(int j=0;j<(int)ans.size();j++)
          cout<<" "<<ans[j];
        cout<<endl;

    }

    return 0;
}

```
