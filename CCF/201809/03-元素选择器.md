
* 测试数据
```
11 5
html
..head
....title
..body
....h1
....p #subtitle
....div #main
......h2
......p #one
......div
........p #two
p
#subtitle
h3
div p
div div p

```


* ```AC代码```

```
#include <bits/stdc++.h>

using namespace std;

const int maxn=105;

struct Node{
    string label,id;///标签,id
    int cnt;
}a[maxn];

int n,m;
string s;

void mystrlwr(string &s){
    for(int i=0;i<(int)s.size();i++)
        s[i]=tolower(s[i]);
}

///在数组a中[1,st](也就是1到st行)寻找缩进小于cnt,且标签或属性等于s的元素
bool search(int &st,int &cnt,string s){
    for(int i=st;i>=1;i--)///往上找父节点
        if(a[i].cnt<cnt){///遍历，说明是要查询的符结点
            ///查询成功
			cnt=a[i].cnt,st=i;///保证a[i]是它的父亲，即第一个缩进小于它的元素
			if(s==a[i].label||s==a[i].id) return true;//成功
        }
    return false;///查询失败
}

int main(){
    scanf("%d%d",&n,&m);
    getchar();
    for(int i=1;i<=n;i++){
        getline(cin,s);
        int cnt=0,pos1=-1,pos2=-1;
        ///cnt记录.数量,pos1记录第一个标签位置,pos2记录是否有'#',即id
        int len=s.size();
        for(int j=0;j<len;j++){
            if(s[j]=='.')
                cnt++;
            else if(pos1==-1&&s[j]!='.')
                pos1=j;
            else if(s[j]=='#')
                pos2=j;
        }
        a[i].cnt=cnt;
        if(pos2==-1){///如果不存在id
            a[i].label=s.substr(pos1);
            a[i].id="";
        }else{
            a[i].label=s.substr(pos1,pos2-pos1-1);
            a[i].id=s.substr(pos2);///不去掉'#'目的:为了标识是id
        }
        mystrlwr(a[i].label);///因为标签大小写不敏感,所以把标签转为小写
        //cout<<"cnt:"<<a[i].cnt<<";label:"<<a[i].label<<";id:"<<a[i].id<<endl;
    }

    for(int i=0;i<m;i++){
        char tmp[100];
        vector<string> query;
        vector<int> ans;
        gets(tmp);
        char *sp=strtok(tmp," ");///分割查询
        while(sp){
            query.push_back(sp);
            sp=strtok(NULL," ");
        }
        int len=query.size();
        for(int j=0;j<len;j++)///将标签统一化成小写
            if(query[j][0]!='#')    mystrlwr(query[j]);

        for(int j=1;j<=n;j++){///匹配n行
            //如果查询的最后一个元素与列相匹配,则继续匹配
            if(query[len-1]==a[j].label||query[len-1]==a[j].id){
        ///st是从哪一行开始遍历查询，cnt为缩进数,查询的元素有多少个，
        ///div div p 这个输入，len=3,
        ///为什么不是-1,因为-1得到的是最后一个要找的内容(第一个if已经匹配)，-2则是倒数第二个内容
                int st=j,cnt=a[j].cnt,k=len-2;///如果存在嵌套，匹配上级,
        ///为什么不是-1,因为-1得到的是最后一个要找的内容(第一个if已经匹配)，-2则是倒数第二个内容
                for(;k>=0;k--)///如果存在嵌套，匹配上级,
                    if(!search(st,cnt,query[k]))    break;
        ///k<0 ，的条件，一，是要寻找的标签只有1个，直接匹配，
        ///二，要寻找的标签有2个或以上，for循环向上匹配，
        ///如果一开始k<0，说明查询只有一个id或者label，因为在最外层已经匹配，所以直接推入匹配标号即可
                if(k<0)
                    ans.push_back(j);
            }
        }

        //输出结果
        cout<<ans.size();
        for(int j=0;j<(int)ans.size();j++)
          cout<<" "<<ans[j];
        cout<<endl;

    }

    return 0;
}

```

* ```90分运行错误代码```

```
#include <bits/stdc++.h>

using namespace std;

struct Line{
    int cnt;///记录缩进
    string label,id;///label记录标签,id记录属性
}line[110];

int n,m;

void mytolowwer(string &str){
    for(int i=0;i<(int)str.size();i++)
        str[i]=tolower(str[i]);
}

vector<string> split(string str){
    vector<string> res;
    char tmp[110];
    strcpy(tmp,str.c_str());///因为.c_str()是const char型,无法直接使用strtok对其进行分割
    char *sp=strtok(tmp," ");
    while(sp){
        res.push_back(sp);
        sp=strtok(NULL," ");
    }
    return res;
}

bool search_(int &st,int &cnt,string s){
    for(int i=st;i>=0;i--){
        if(line[i].cnt<cnt){
            cnt=line[i].cnt;
            st=i;///再上一级
            if(s==line[i].label||s==line[i].id)
                return true;
        }
    }
    return false;
}

int main(){
    string tmpline;
    scanf("%d%d",&n,&m);
    getchar();
    for(int i=0;i<n;i++){
        getline(cin,tmpline);
        int cnt=0,p1=-1,p2=-1;
        int len1=tmpline.size();
        for(int j=0;j<len1;j++){
            if(tmpline[j]=='.')
                cnt++;
            else if(p1==-1&&isalpha(tmpline[j]))
                p1=j;
            else if(tmpline[j]=='#')
                p2=j;
        }
        if(p2==-1){///如果不存在属性
            line[i].label=tmpline.substr(p1);
        }
        else{///存在属性
            line[i].label=tmpline.substr(p1,p2-p1-1);
            line[i].id=tmpline.substr(p2);
        }
        line[i].cnt=cnt;
        //cout<<"label:"<<line[i].label<<";id:"<<line[i].id<<";cnt:"<<line[i].cnt<<endl;
        mytolowwer(line[i].label);
    }
    scanf("%d",&m);
    vector<string> query;
    for(int i=0;i<m;i++){
        vector<int> ans;
        getline(cin,tmpline);
        query=split(tmpline);
        //for(int j=0;j<(int)vec.size();j++){
        //    cout<<vec[j]<<" ";
        //}
        //cout<<endl;
        int len2=query.size();
        for(int j=0;j<len2;j++)///将标签转为小写
            if(query[j][0]!='#')  mytolowwer(query[j]);
        for(int j=0;j<n;j++){///匹配n行
            if(query[len2-1]==line[j].label||query[len2-1]==line[j].id){
                int st=j;///可能存在嵌套,所以向上找
                int cnt=line[j].cnt;
                int k=len2-2;///寻找上级
        ///为什么不是-1,因为-1得到的是最后一个要找的内容(第一个if已经匹配)，-2则是倒数第二个内容
                for(;k>=0;k--){
                    if(!search_(st,cnt,query[k]))
                        break;
                }
                if(k<0)///如果匹配成功,将该行推入
                    ans.push_back(j);
            }
        }
        printf("%d",(int)ans.size());
        for(int j=0;j<(int)ans.size();j++)
            printf(" %d",ans[j]+1);
        printf("\n");
    }

    return 0;
}


```








