
* 11分代码
```
#include <bits/stdc++.h>

using namespace std;

const int maxn=1010;

set<int> st[maxn],peo;
int n,k,cnt,x;

int main(){
    scanf("%d%d",&n,&k);
    for(int i=0;i<k;i++){
        scanf("%d",&cnt);
        for(int j=0;j<cnt;j++){
            scanf("%d",&x);
            st[i].insert(x);
            peo.insert(x);
        }
    }
    int rx,ry;
    scanf("%d%d",&rx,&ry);
    double s1=0;///计算rx与ry之间的亲密度
    for(int i=0;i<k;i++){
        if(st[i].find(rx)!=st[i].end()&&st[i].find(ry)!=st[i].end()){
            s1+=1.0/((int)st[i].size());
        }
    }
    double sa=0;///计算与A最亲密的人
    set<int> sta,sta1,sta2;///sta,;sta1,记录编号大于0的；sta2，记录编号小于0的
    //map<int,int> mpa;
    set<int>::iterator it=peo.begin();
    for(;it!=peo.end();it++){
        double tmp=0;
        for(int i=0;i<k;i++){
            if(st[i].find(rx)!=st[i].end()&&st[i].find(*it)!=st[i].end()&&(*it)!=rx){
                tmp+=1.0/((int)st[i].size());
            }
        }
        sa=max(tmp,sa);
    }

    for(it=peo.begin();it!=peo.end();it++){
        double tmp=0;
        for(int i=0;i<k;i++){
            if(st[i].find(rx)!=st[i].end()&&st[i].find(*it)!=st[i].end()){
                tmp+=1.0/((int)st[i].size());
            }
        }
        if(tmp==sa&&(((*it)>=0&&rx<0)||((*it)<0&&rx>=0))){
            sta.insert(*it);
            if(*it>=0)   sta1.insert(*it);
            else    sta2.insert(*it);
        }
    }

    //it=sta.begin();
    //for(;it!=sta.end();it++)
    //    cout<<*it<<" ";
    //cout<<endl;

    double sb=0;///计算与B最亲密的人
    set<int> stb,stb1,stb2;
    for(it=peo.begin();it!=peo.end();it++){
        double tmp=0;
        for(int i=0;i<k;i++){
            if(st[i].find(ry)!=st[i].end()&&st[i].find(*it)!=st[i].end()&&(*it)!=ry){
                tmp+=1.0/((int)st[i].size());
            }
        }
        //cout<<*it<<" "<<tmp<<endl;
        sb=max(tmp,sb);
    }

    //cout<<sb<<endl;
    for(it=peo.begin();it!=peo.end();it++){
        double tmp=0;
        for(int i=0;i<k;i++){
            if(st[i].find(ry)!=st[i].end()&&st[i].find(*it)!=st[i].end()){
                tmp+=1.0/((int)st[i].size());
            }
        }
        //cout<<(((*it)>0&&ry<0)||((*it)<0&&ry>0))<<endl;
        if(tmp==sb&&(((*it)>=0&&ry<0)||((*it)<0&&ry>=0))){
            stb.insert(*it);
            if(*it>=0)   stb1.insert(*it);
            else    stb2.insert(*it);
        }
    }

    //it=stb.begin();
    //for(;it!=stb.end();it++)
    //    cout<<*it<<" ";
    if(sta.find(ry)!=sta.end()&&stb.find(rx)!=stb.end()){
        printf("%d %d\n",rx,ry);
        return 0;
    }
    ///输出与A最亲密的人
    bool flaga=(sta1.find(rx)!=sta1.end())||(sta2.find(rx)!=sta2.end());
    if(flaga==false){
    set<int>::iterator ita;
    set<int>::reverse_iterator rita;
    if(rx>=0)///若A为正，则输出负号的集合，
    for(rita=sta2.rbegin();rita!=sta2.rend();rita++){
        cout<<rx<<" "<<(*rita)<<endl;
    }
    else
    for(ita=sta1.begin();ita!=sta1.end();ita++){
        cout<<rx<<" "<<(*ita)<<endl;
    }
    }

    ///输出与B最亲密的人
    bool flagb=(stb1.find(ry)!=stb1.end())||(stb2.find(ry)!=stb2.end());
    if(flagb==false){
    set<int>::iterator itb;
    set<int>::reverse_iterator ritb;
    if(ry>=0)
    for(ritb=stb2.rbegin();ritb!=stb2.rend();ritb++){
        cout<<ry<<" "<<(*ritb)<<endl;
    }
    else
    for(itb=stb1.begin();itb!=sta1.end();itb++){
        cout<<ry<<" "<<(*itb)<<endl;
    }
    }

    return 0;
}
```

* ```set<int>```逆序遍历
  * 需要用逆向迭代器```set<int>::reverse_iterator```
  
  
```
#include <iostream>
#include <set>

using namespace std;

int main(int argc, char* argv[])
{
	set<int> st;
	st.insert(1);
	st.insert(2);
	st.insert(3);

	for(set<int>::reverse_iterator it=st.rbegin();it!=st.rend();it++){
        cout<<*it<<endl;
	}
	cout << *(st.rbegin()) << endl; // 输出：3
	cout << *(--st.rend()) << endl; // 输出：1

	cout << endl;

	return 0;
}
```
