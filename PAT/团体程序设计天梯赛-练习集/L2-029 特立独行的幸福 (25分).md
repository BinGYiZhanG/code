
### 思路：
* [转自CSDN](https://blog.csdn.net/qq_41376345/article/details/89053324)
```
for(int i=left;i<=right;i++)	{
  int n=i,sum=0;
  vector<int> v;
  while(n!=1){
    sum=0;
    while(n){///求数的各个位的平方和
      sum+=(n%10)*(n%10);
      n/=10;
    }
    n=sum;
    if(find(v.begin(),v.end(),sum)!=v.end()) ///如果数组中找到这个数了，说明它依附于其他的数
      break; //判断重复
    v.push_back(n);///将更新后的数推入
    appear[n]=1;///置为1,如果在过程中被记录，说明这个数形似与例子给出的10,13，是幸福数，但依附于其他数
  }
  if(n==1) result[i]=v.size();
}
```


```
#include <bits/stdc++.h>

using namespace std;

int is_prime(int n){
	if(n<2) return 1;
	for(int i=2;i<=(int)sqrt(n);i++){
		if(n%i==0) return 1;
	}
	return 2;
}

int main(){
	int left,right,appear[100001]={0};
	cin>>left>>right;
	map<int,int> result;
	for(int i=left;i<=right;i++)	{
		int n=i,sum=0;
		vector<int> v;
		while(n!=1){
			sum=0;
			while(n){///求数的各个位的平方和
				sum+=(n%10)*(n%10);
				n/=10;
			}
			n=sum;
			if(find(v.begin(),v.end(),sum)!=v.end()) ///如果数组中找到这个数了，说明它依附于其他的数
				break; //判断重复
			v.push_back(n);///将更新后的数推入
			appear[n]=1;///置为1,如果在过程中被记录，说明这个数形似与例子给出的10,13，是幸福数，但依附于其他数
		}
		if(n==1) result[i]=v.size();
	}
	map<int,int>::iterator it;
	int flag=0;
	for(it=result.begin();it!=result.end();it++){
		if(!appear[it->first]){
			printf("%d %d\n",it->first,it->second*is_prime(it->first));
			flag=1;
		}
	}
	if(flag==0) printf("SAD");
	return 0;
}

```
