### 1122 Hamiltonian Cycle (25分)
* 哈密顿环，就是一个简单环，其中所有结点都在一张图中
  * 起点和终点是同一个结点，点数=图中节点数+1
  * 连通
  

### 1126 Eulerian Path (25分)
#### 题意
* 所有的欧拉路径开始于一个节点，终止于另一个结点
* 所有结点的度数为偶数，为欧拉图;有两个结点的度数为奇数，则为半欧拉图
#### 输出
* 所有结点的度数，和```Eulerian, Semi-Eulerian, or Non-Eulerian ```

### 1127 ZigZagging on a Tree (30分)
#### 题意
* 给出树的中序遍历和后序遍历
#### 输出
* 打印树的```zigzagging```序列
#### 思路

* 静态结点的建树代码
```
int tree[35][2];
void dfs(int &index, int inLeft, int inRight, int postLeft, int postRight) {
	if (inLeft > inRight)
		return;
	index = postRight;//根节点
	int i = 0;
	while (in[i] != post[postRight])i++;
	//
	dfs(tree[index][0], inLeft, i - 1, postLeft, postLeft + (i - inLeft) - 1);
	dfs(tree[index][1], i + 1, inRight, postLeft + (i - inLeft), postRight - 1);
}
```

* 层序遍历（记录层号）
```
struct node {
	int index, depth;
};

void bfs() {
	queue<node> q;
	q.push(node{ root,0 });
	while (!q.empty()) {
		node temp = q.front();
		q.pop();
		result[temp.depth].push_back(post[temp.index]);
		if (tree[temp.index][0] != 0)
			q.push(node{ tree[temp.index][0],temp.depth + 1 });
		if (tree[temp.index][1] != 0)
			q.push(node{ tree[temp.index][1],temp.depth + 1 });
	}
}
```

* 输出
```
printf("%d", result[0][0]);
for (int i = 1; i < 35; i++) {
	if (i % 2 == 1) {//奇数层
		for (int j = 0; j < result[i].size(); j++)
			printf(" %d", result[i][j]);
	}
	else {
		for (int j = result[i].size() - 1; j >= 0; j--)
			printf(" %d", result[i][j]);
	}
}
```

### 1128 N Queens Puzzle (20分)
```
行号 减 列号

8 7 6  5  4
7 6 5  4  3
6 5 4  3  2
5 4 3  2  1
4 3 2  1  0
3 2 1  0  -1
2 1 0  -1 -2
1 0 -1 -2 -3 
  1 2  3  4  5 6 7 8 



```

### 1129 Recommendation System (25分)

* 结构体重载运算符
```
struct node {
	int value, cnt;
	bool operator <(const node &a) const  {
		return cnt != a.cnt ? cnt > a.cnt:value < a.value;
	}
};//最后应该有一个分号

int main() {
	int n, k, num;
	set<node> st;

```
* [PAT Car On Campus重载运算符](https://blog.csdn.net/qq_16949707/article/details/51579926)
* [结构体运算符重载](https://blog.csdn.net/sunny1996/article/details/51242184/)


### 1137 Final Grading (25分)
* 输入
  * ```P个Gp成绩,M个Gm成绩,N个Gf成绩```
* 输出
  * 格式：```StudentID Gp Gmid-term Gfinal G```



