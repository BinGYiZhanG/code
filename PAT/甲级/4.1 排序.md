
### 1006 Sign In and Sign Out (25分)
* 针对时间排序，转换成数字
```
int signin=hh1*3600+mm1*60+ss1;
int signout=hh2*3600+mm1*60+ss2;
```

### 1012 The Best Rank (25分)

* 1,按优先级顺序存储字母，方便输出
```
char course[4]={'A','C','M','E'};///按优先级顺序,方便输出

int query;///查询的考生ID
for(int i=0;i<m;i++){
    scanf("%d",&query);
    if(Rank[query][0]==0)
        printf("N/A\n");
    else{
        int k=0;
        for(int j=0;j<4;j++)
            if(Rank[query][j]<Rank[query][k])   k=j;
        printf("%d %c\n",Rank[query][k],course[k]);
    }
}
```
* 2,平均数取整
```
for(int i=0;i<n;i++){
    scanf("%d%d%d%d",&stu[i].id,&stu[i].grade[1],&stu[i].grade[2],&stu[i].grade[3]);
    stu[i].grade[0]=(stu[i].grade[1]+stu[i].grade[2]+stu[i].grade[3])/3.0+0.5;
}
```
* 3,按照```now```编号排序
```
int now;///cmp函数中使用,表示当前按now号分数排序stu数组

bool cmp(const Student &a,const Student &b){
    return a.grade[now]>b.grade[now];
}

///枚举A,C,M,E 4个中的一个
for(now=0;now<4;now++){
    sort(stu,stu+n,cmp);///对所有考生按该分数从大到小排序
    Rank[stu[0].id][now]=1;///排序完，将分数最高的设为rank1
    for(int i=1;i<n;i++){///对于剩下的考生
        ///若与前一位考生分数相同
        if(stu[i].grade[now]==stu[i-1].grade[now]){
            Rank[stu[i].id][now]=Rank[stu[i-1].id][now];///则他们的排名相同
        }
        else{
            Rank[stu[i].id][now]=i+1;///否则，为其设置正确的排名
        }
    }
}
```


### 1016 Phone Bills (25分)
* 1,利用数组最后一位记录一整天的通话费用
```
double billFromZero(node call, int *rate) {
    ///在该小时下分钟数*该小时下的通话费用 + 天数*（各个时间段的通话费用（按小时划分，共24小时））*60
	double total = rate[call.hour] * call.minute + rate[24] * 60 * call.day;
	//计算每分钟的费用               +             每天的费用
    ///计算call.hour之前小时的通话总费用，
	for (int i = 0; i < call.hour; i++)
		total += rate[i] * 60;
	//计算每小时的费用
	
	return total / 100.0;
	//转换为正常的费用
}

int rate[25] = { 0 }, n;
for (int i = 0; i < 24; i++) {
  scanf("%d", &rate[i]);
  rate[24] += rate[i];///24小时各个时间段的费用:通话每分钟的费用
}
```
* 2,把时间转换为分钟
```
for (int i = 0; i < n; i++) {
  cin >> data[i].name;
  scanf("%d:%d:%d:%d", &data[i].month, &data[i].day, &data[i].hour, &data[i].minute);
  string temp;
  cin >> temp;
  data[i].status = (temp == "on-line") ? 1 : 0;
  data[i].time = data[i].day * 24 * 60 + data[i].hour * 60 + data[i].minute;///time是以分钟为单位
}
```

* 3,按照姓名记录通话记录
```
map<string, vector<node> > custom;
for (int i = 1; i < n; i++) {///输入合法的通话记录
  if (data[i].name == data[i - 1].name&&data[i - 1].status == 1 && data[i].status == 0) {
    custom[data[i - 1].name].push_back(data[i - 1]);
    custom[data[i].name].push_back(data[i]);
  }
}

```

### 1025 PAT Ranking (25分)
* 



### 1062 Talent and Virtue (25分)
* 把分类成员按照标准分成几类
```
bool cmp(info a,info b){
    if(a.clas != b.clas) return a.clas < b.clas;
    else if(a.sum != b.sum) return a.sum > b.sum;
    else if(a.de_s != b.de_s) return a.de_s > b.de_s;
    else return strcmp(a.num,b.num) < 0;
}

for(int i = 0;i < N; i++) {
    scanf("%s %d %d",&stu[i].num,&stu[i].de_s,&stu[i].cai_s);
    stu[i].sum = stu[i].de_s + stu[i].cai_s;
    if(stu[i].de_s < L || stu[i].cai_s < L) {//德才分有一个不及格 的人 不会被记录 5
        stu[i].clas = 5;
        cnt--;//及格人数减少1 
    }
    else if(stu[i].de_s >= H && stu[i].cai_s >= H) stu[i].clas = 1;//德才分不低于H的,称为“sages”,按总分的递增序排序 1
    else if(stu[i].de_s >= H && stu[i].cai_s < H) stu[i].clas = 2;//才分低于H,但德分高于H,称为"noblemen",按总分的递增序排序 2
    else if(stu[i].de_s < H && stu[i].cai_s < H && stu[i].de_s >= stu[i].cai_s) stu[i].clas = 3;//德才分均低于H,但德分不低于才分被称为"fool men" 3
    else stu[i].clas = 4;//剩余的人排在最后 4
}
```


