
### 总分93

#### ``` 7-1 Good in C (20分)``` 13分
```

#include <bits/stdc++.h>

using namespace std;

char line[26][10][8];
//char lines[10][8];
char out[15];
char res[100][100];///输出


int flagrow[100];

int main(){

    for(int k=0;k<26;k++)///26个英文字母
        for(int i=1;i<=7;i++){

            scanf("%c%c%c%c%c",&line[k][i][0],&line[k][i][1],&line[k][i][2],&line[k][i][3],&line[k][i][4]);
            //scanf("%s",line[k][i]);
       //     scanf("%s",lines[i]);
            getchar();
        }
    //cout<<endl;
    //printf("=================================\n");
    //for(int k=0;k<26;k++)///26个英文字母
    //    for(int i=1;i<=7;i++)
    //        printf("%s\n",line[k][i]);
    //        printf("%s\n",lines[i]);

    scanf("%s",out);

    int curi=0,len=strlen(out);
    int currow=0;

    while(!isupper(out[curi]))  curi++;

    while(curi<len){
        int newi=curi+1;
        while(newi<len&&isupper(out[newi])) newi++;///newi=5
        for(int row=1;row<=7;row++){///一共7行
            int lienum=0;
            for(int i=curi;i<newi;i++){///一行的字母,0~4
                for(int j=0;j<5;j++)///一行5个标志
                    res[currow][lienum++]=line[out[i]-'A'][row][j];
                if(i!=newi-1)
                    res[currow][lienum++]=' ';
                //printf("%s ",line[out[i]-'A'][row]);
            }
            res[currow][lienum++]='\n';
            res[currow][lienum]='\0';
            //printf("%d行:%s",currow,res[currow]);
            currow++;
        }
        curi=newi;
        while(!isupper(out[curi]))  curi++;
        if(curi<len){
            //printf("\n");
            res[currow][0]='\n';
            res[currow++][1]='\0';
            //printf("%d行:%s",currow-1,res[currow-1]);
        }
    }

    for(int i=0;i<currow;i++){
        //printf("%s\n",res[i]);
        printf("%s",res[i]);
    }
    //printf("===========================\n\n");
   // }
    return 0;
}

```


#### ``` 7-2 Block Reversing (25分)```AC
```
#include <bits/stdc++.h>

using namespace std;

const int maxn=100010;
struct Node{
    int address;
    int data;
    int nextt;
    int order;
}node[maxn];

vector<Node> tmpv;
vector<vector<Node> > vec;
bool cmp(const Node &a,const Node &b){
    return a.order<b.order;
}

void Init(){
    for(int i=0;i<100000;i++)
        node[i].order=maxn;
}

int main(){
    Init();
    int st,n,k,addr;
    scanf("%d%d%d",&st,&n,&k);
    for(int i=0;i<n;i++){
        scanf("%d",&addr);
        node[addr].address=addr;
        scanf("%d%d",&node[addr].data,&node[addr].nextt);
    }
    int p=st,cnt=0;
    while(p!=-1){
        node[p].order=(cnt++);
        p=node[p].nextt;
    }
   // p=st;
    //while(p!=-1){
    //    printf("%05d %d %05d\n",node[p].address,node[p].data,node[p].nextt);
    //    p=node[p].nextt;
    //}

    int blocks;///块数

    if(cnt%k==0)
        //printf("%d %d\n",cnt/k,cnt);
        blocks=cnt/k;
    else
        //printf("%d %d\n",cnt/k+1,cnt);
        blocks=cnt/k+1;
    p=st;
    for(int i=0;i<blocks;i++){
        tmpv.clear();
        if(i==blocks-1&&cnt%k!=0){///最后一块,
            for(int j=(i-1)*k;j<cnt&&p!=-1;j++){///得加p!=-1
            //printf("最后:%05d %d %05d\n",node[p].address,node[p].data,node[p].nextt);
                tmpv.push_back(node[p]);
                p=node[p].nextt;
            }
            vec.push_back(tmpv);
        }
        else{
            for(int j=i*k;j<(i+1)*k&&p!=-1;j++){
            //printf("中间%d个:%05d %d %05d\n",i,node[p].address,node[p].data,node[p].nextt);
                tmpv.push_back(node[p]);
                p=node[p].nextt;
            }
            vec.push_back(tmpv);
        }
    }

   // printf("====================\n");
    //sort(vec.begin(),vec.end());
    if(cnt==0)
        printf("-1\n");
    else{
        for(int i=vec.size()-1;i>=0;i--){
            int len=vec[i].size();
            if(i!=0){
                for(int j=0;j<len;j++){
                    if(j!=len-1)
                        printf("%05d %d %05d\n",vec[i][j].address,vec[i][j].data,vec[i][j+1].address);
                    else
                        printf("%05d %d %05d\n",vec[i][j].address,vec[i][j].data,vec[i-1][0].address);
                }
            }
            else{
                for(int j=0;j<(int)vec[i].size();j++){
                    if(j!=len-1)
                        printf("%05d %d %05d\n",vec[i][j].address,vec[i][j].data,vec[i][j+1].address);
                    else
                        printf("%05d %d -1\n",vec[i][j].address,vec[i][j].data);
                }
            }
        }
    }

    return 0;
}


```


#### ```7-3 Summit (25分) ```AC

```
#include <bits/stdc++.h>

using namespace std;

/*
N,首脑数量;M,关系数

K,k行分配
L,L个首脑

如果每个人都是其他人的直接朋友，也就是说,
打印 Area X is OK
如果一些首脑也被邀请,
打印 Area X may invite more people, such as H
H 是被邀请最小的人

X 在区间[1,K]

*/

int e[210][210];
int tmp[210];
int n,m,k;
set<int> st;

int main(){
    scanf("%d%d",&n,&m);
    int a,b;
    memset(e,0,sizeof(e));
    for(int i=0;i<m;i++){
        scanf("%d%d",&a,&b);
        e[a][b]=e[b][a]=1;

    }
    scanf("%d",&k);
    int cnt;
    bool flag;
    for(int i=1;i<=k;i++){
        scanf("%d",&cnt);
        st.clear();
        for(int j=0;j<cnt;j++){
            scanf("%d",&tmp[j]);
            st.insert(tmp[j]);
        }
        flag=true;
        for(int j=0;j<cnt;j++){
            for(int v=0;v<cnt;v++){
                if(v==j)    continue;
                else {
                    if(!e[tmp[j]][tmp[v]]){
                        flag=false;
                        break;
                    }
                }
            }
            if(!flag)
                break;
        }
        if(!flag){
            printf("Area %d needs help.\n",i);
        }
        else{
            int tmpcnt=0;
            int minindex=300;
            for(int j=1;j<=n;j++){
                if(st.find(j)!=st.end())    continue;///如果发现了说明已经在圈内，continue
                bool tmpf=true;
                for(int v=0;v<cnt;v++){
                    if(e[j][tmp[v]]==0){
                        tmpf=false;
                    }
                }
                if(tmpf){
                    tmpcnt++;
                    minindex=min(minindex,j);
                }
            }
            if(tmpcnt)
                printf("Area %d may invite more people, such as %d.\n",i,minindex);
            else
                printf("Area %d is OK.\n",i);
        }
    }
    return 0;
}
```

#### ```7-4 Cartesian Tree (30分) ```AC
```
#include <bits/stdc++.h>

using namespace std;

struct Node{
    int data;
    Node *lchild,*rchild;
};

int num[40];
int n;

Node* create(int inL,int inR){
    if(inL>inR)
        return NULL;
    int rooti,minn=0x3f3f3f3f;
    for(int i=inL;i<=inR;i++){
        if(minn>num[i]){
            minn=num[i];
            rooti=i;
        }
    }
    Node* root=new Node;
    root->data=num[rooti];
    root->lchild=create(inL,rooti-1);
    root->rchild=create(rooti+1,inR);
    return root;///返回根，而非NULL
}

void InOrder(Node *root){
    if(root==NULL)
        return ;
    InOrder(root->lchild);
    printf("%d-",root->data);
    InOrder(root->rchild);
}

int main(){

    scanf("%d",&n);

    for(int i=0;i<n;i++){
        scanf("%d",&num[i]);
    }

    Node* root=create(0,n-1);

    queue<Node*> q;
    vector<int> v;

    q.push(root);//bfs层序遍历
    while(!q.empty()){
        Node *tree=q.front();
        q.pop();
        v.push_back(tree->data);
        if(tree->lchild) q.push(tree->lchild);
        if(tree->rchild) q.push(tree->rchild);
    }

    int len=v.size();
    for(int i=0;i<len;i++)//输出
        printf("%s%d",(i==0?"":" "),v[i]);


    return 0;
}

```
