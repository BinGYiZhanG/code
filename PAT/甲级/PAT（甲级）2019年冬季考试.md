
### 总分93==>97

#### ``` 7-1 Good in C (20分)``` 13分==>17分
* ```scanf```无法读取空格,需要用```getline```读取空格
* ```char```数组还得开得大一点,这种字符串的题就应该用```string```做,不可能判断超时
* 最后的错误:```测试点4 运行时错误```（PAT给出的可能情况是:数组访问越界,）
```
#include <bits/stdc++.h>

using namespace std;

char line[30][10][8];///数组得开的大一点才可以
//char lines[10][8];
char out[110];
char res[1010][1010];///输出
string tmpout;

int flagrow[100];

int main(){

    for(int k=0;k<26;k++)///26个英文字母
        for(int i=1;i<=7;i++){

            scanf("%c%c%c%c%c",&line[k][i][0],&line[k][i][1],&line[k][i][2],&line[k][i][3],&line[k][i][4]);
            //scanf("%s",line[k][i]);
       //     scanf("%s",lines[i]);
            getchar();
        }
    //cout<<endl;
    //printf("=================================\n");
    //for(int k=0;k<26;k++)///26个英文字母
    //    for(int i=1;i<=7;i++)
    //        printf("%s\n",line[k][i]);
    //        printf("%s\n",lines[i]);

    //scanf("%s",out);
    getline(cin,tmpout);///测试点1,2有空格
    strcpy(out,tmpout.c_str());
    int curi=0,len=strlen(out);
    int currow=0;
    //memset(res,0,sizeof(res));

    while(curi<len){
        while(!isupper(out[curi]))  curi++;
        int newi=curi+1;
        while(newi<len&&isupper(out[newi])) newi++;///newi=5
        for(int row=1;row<=7;row++){///一共7行
            int lienum=0;
            for(int i=curi;i<newi;i++){///一行的字母,0~4
                for(int j=0;j<5;j++)///一行5个标志
                    res[currow][lienum++]=line[out[i]-'A'][row][j];
                if(i!=newi-1)
                    res[currow][lienum++]=' ';
                //printf("%s ",line[out[i]-'A'][row]);
            }
            res[currow][lienum++]='\n';
            res[currow][lienum]='\0';
            //printf("%d行:%s",currow,res[currow]);
            currow++;
        }
        curi=newi;
        while(!isupper(out[curi]))  curi++;
        if(curi<len&&curi!=newi){
            //printf("\n");
            res[currow][0]='\n';
            res[currow++][1]='\0';
            //printf("%d行:%s",currow-1,res[currow-1]);
        }
    }

    for(int i=0;i<currow;i++){
        //printf("%s\n",res[i]);
        printf("%s",res[i]);
    }
    //printf("===========================\n\n");
   // }
    return 0;
}

```
* AC代码
  * 先处理最后输入的字符串,而后将字符串输出
```
#include <cstdio>
#include <vector>
#include <algorithm>
#include <set>
#include <string>
#include <iostream>
using namespace std;
char letter[300][7][5];
void print(string str){
	for (int row=0; row<7; row++){
		for (int index=0; index<(int)str.length(); index++){///例如:打印HELLO,的字符串格式
			char let=str[index];
			for (int col=0; col<5; col++){
				printf("%c", letter[let][row][col]);
			}
			if (index!=str.length()-1) printf(" ");
		}
		printf("\n");
	}
}
int main(){
	for (int i='A'; i<='Z'; i++){
		for (int j=0; j<7; j++){
			for (int k=0; k<5; k++){
				scanf("%c",&letter[i][j][k]);
			}
			getchar();
		}
	}
	string str;
	getline(cin,str);
	vector<string> vt;
	int pre=0;
	int i=0;
	for (i=0; i<str.length(); i++){
		if (!(str[i]>='A' && str[i]<='Z')){///如果不是大写字母
			string temp=str.substr(pre, i-pre);///
			if (temp!="") vt.push_back(temp);
			pre=i;///pre=5,i=5
			while (!(str[i]>='A' && str[i]<='Z')) {
				i++;///大写字母串结尾后移,i=6,下一步,i=11
				pre++;///大写字母串开头后移,pre=6,
			}
		}
	}
	if (pre<str.length()) {///如果到最后,最后一个字母是大写字母,例如:HELLO~WORLD,即pre=6,i=len
		string temp=str.substr(pre, str.length()-pre);
		vt.push_back(temp);
	}
	for (int i=0; i<vt.size(); i++){
		print(vt[i]);
		if (i!=vt.size()-1) printf("\n");
	}
}

```


#### ``` 7-2 Block Reversing (25分)```AC
* 注意从一个块到下一个块的遍历
```
#include <bits/stdc++.h>

using namespace std;

const int maxn=100010;
struct Node{
    int address;
    int data;
    int nextt;
    int order;
}node[maxn];

vector<Node> tmpv;
vector<vector<Node> > vec;
bool cmp(const Node &a,const Node &b){
    return a.order<b.order;
}

void Init(){
    for(int i=0;i<100000;i++)
        node[i].order=maxn;
}

int main(){
    Init();
    int st,n,k,addr;
    scanf("%d%d%d",&st,&n,&k);
    for(int i=0;i<n;i++){
        scanf("%d",&addr);
        node[addr].address=addr;
        scanf("%d%d",&node[addr].data,&node[addr].nextt);
    }
    int p=st,cnt=0;
    while(p!=-1){
        node[p].order=(cnt++);
        p=node[p].nextt;
    }
   // p=st;
    //while(p!=-1){
    //    printf("%05d %d %05d\n",node[p].address,node[p].data,node[p].nextt);
    //    p=node[p].nextt;
    //}

    int blocks;///块数

    if(cnt%k==0)
        //printf("%d %d\n",cnt/k,cnt);
        blocks=cnt/k;
    else
        //printf("%d %d\n",cnt/k+1,cnt);
        blocks=cnt/k+1;
    p=st;
    for(int i=0;i<blocks;i++){
        tmpv.clear();
        if(i==blocks-1&&cnt%k!=0){///最后一块,
            for(int j=(i-1)*k;j<cnt&&p!=-1;j++){///得加p!=-1
            //printf("最后:%05d %d %05d\n",node[p].address,node[p].data,node[p].nextt);
                tmpv.push_back(node[p]);
                p=node[p].nextt;
            }
            vec.push_back(tmpv);
        }
        else{
            for(int j=i*k;j<(i+1)*k&&p!=-1;j++){
            //printf("中间%d个:%05d %d %05d\n",i,node[p].address,node[p].data,node[p].nextt);
                tmpv.push_back(node[p]);
                p=node[p].nextt;
            }
            vec.push_back(tmpv);
        }
    }

   // printf("====================\n");
    //sort(vec.begin(),vec.end());
    if(cnt==0)
        printf("-1\n");
    else{
        for(int i=vec.size()-1;i>=0;i--){
            int len=vec[i].size();
            if(i!=0){
                for(int j=0;j<len;j++){
                    if(j!=len-1)
                        printf("%05d %d %05d\n",vec[i][j].address,vec[i][j].data,vec[i][j+1].address);
                    else
                        printf("%05d %d %05d\n",vec[i][j].address,vec[i][j].data,vec[i-1][0].address);
                }
            }
            else{
                for(int j=0;j<(int)vec[i].size();j++){
                    if(j!=len-1)
                        printf("%05d %d %05d\n",vec[i][j].address,vec[i][j].data,vec[i][j+1].address);
                    else
                        printf("%05d %d -1\n",vec[i][j].address,vec[i][j].data);
                }
            }
        }
    }

    return 0;
}


```


#### ```7-3 Summit (25分) ```AC
* 和```1142 Maximal Clique (25分)```一样
```
#include <bits/stdc++.h>

using namespace std;

/*
N,首脑数量;M,关系数

K,k行分配
L,L个首脑

如果每个人都是其他人的直接朋友，也就是说,
打印 Area X is OK
如果一些首脑也被邀请,
打印 Area X may invite more people, such as H
H 是被邀请最小的人

X 在区间[1,K]

*/

int e[210][210];
int tmp[210];
int n,m,k;
set<int> st;

int main(){
    scanf("%d%d",&n,&m);
    int a,b;
    memset(e,0,sizeof(e));
    for(int i=0;i<m;i++){
        scanf("%d%d",&a,&b);
        e[a][b]=e[b][a]=1;

    }
    scanf("%d",&k);
    int cnt;
    bool flag;
    for(int i=1;i<=k;i++){
        scanf("%d",&cnt);
        st.clear();
        for(int j=0;j<cnt;j++){
            scanf("%d",&tmp[j]);
            st.insert(tmp[j]);
        }
        flag=true;
        for(int j=0;j<cnt;j++){
            for(int v=0;v<cnt;v++){
                if(v==j)    continue;
                else {
                    if(!e[tmp[j]][tmp[v]]){
                        flag=false;
                        break;
                    }
                }
            }
            if(!flag)
                break;
        }
        if(!flag){
            printf("Area %d needs help.\n",i);
        }
        else{
            int tmpcnt=0;
            int minindex=300;
            for(int j=1;j<=n;j++){
                if(st.find(j)!=st.end())    continue;///如果发现了说明已经在圈内，continue
                bool tmpf=true;
                for(int v=0;v<cnt;v++){
                    if(e[j][tmp[v]]==0){
                        tmpf=false;
                    }
                }
                if(tmpf){
                    tmpcnt++;
                    minindex=min(minindex,j);
                }
            }
            if(tmpcnt)
                printf("Area %d may invite more people, such as %d.\n",i,minindex);
            else
                printf("Area %d is OK.\n",i);
        }
    }
    return 0;
}
```

#### ```7-4 Cartesian Tree (30分) ```AC
* 每次遍历树中最小结点作为根,再建树

```
#include <bits/stdc++.h>

using namespace std;

struct Node{
    int data;
    Node *lchild,*rchild;
};

int num[40];
int n;

Node* create(int inL,int inR){
    if(inL>inR)
        return NULL;
    int rooti,minn=0x3f3f3f3f;
    for(int i=inL;i<=inR;i++){
        if(minn>num[i]){
            minn=num[i];
            rooti=i;
        }
    }
    Node* root=new Node;
    root->data=num[rooti];
    root->lchild=create(inL,rooti-1);
    root->rchild=create(rooti+1,inR);
    return root;///返回根，而非NULL
}

void InOrder(Node *root){
    if(root==NULL)
        return ;
    InOrder(root->lchild);
    printf("%d-",root->data);
    InOrder(root->rchild);
}

int main(){

    scanf("%d",&n);

    for(int i=0;i<n;i++){
        scanf("%d",&num[i]);
    }

    Node* root=create(0,n-1);

    queue<Node*> q;
    vector<int> v;

    q.push(root);//bfs层序遍历
    while(!q.empty()){
        Node *tree=q.front();
        q.pop();
        v.push_back(tree->data);
        if(tree->lchild) q.push(tree->lchild);
        if(tree->rchild) q.push(tree->rchild);
    }

    int len=v.size();
    for(int i=0;i<len;i++)//输出
        printf("%s%d",(i==0?"":" "),v[i]);


    return 0;
}

```
