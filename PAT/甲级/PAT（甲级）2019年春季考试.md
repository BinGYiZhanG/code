### 问题
* 1题（遍历```n```应该用```while```），
* 3题（一个深度遍历，确定```gang```,我一开始写成并查集，没法想象）


### 7-1 Sexy Primes (20分)
```
#include <bits/stdc++.h>

using namespace std;

bool judge(int n){
    if(n<=1)    return false;
    int sqr=sqrt(n*1.0);
    for(int i=2;i<=sqr;i++)
        if(n%i==0)  return false;

    return true;
}

int main()
{
    int n;
    scanf("%d",&n);

    if(judge(n)&&judge(n-6)){///输出性感数对，小的那个
        printf("Yes\n%d\n",n-6);
    }
    else if(judge(n)&&judge(n+6)){
        printf("Yes\n%d\n",n);
    }
    else{
        int i=n+1;
        while(i++){//不应该用for循环，测试点4
            if(judge(i-6)&&judge(i)){
                printf("No\n%d\n",(i-6)<n?i:i-6);
                break;
            }
            else if(judge(i)&&judge(i+6)){
                printf("No\n%d\n",i);
                break;
            }
        }

    }

    return 0;
}

```
### 7-2 Anniversary (25分)
```
#include <bits/stdc++.h>

using namespace std;

/*题意:
计算到场的校友数量
N,
接下来N行，是校友ID
校友ID是18位长的数字或者最后包含X
ID唯一

接下来一行给出，所有到场的人的信息,
M行


输出：
line1：校友数量
line2：打印最老的校友
7~14位是到场人员的生日

*/

set<string> st;
map<string,int> mp;

int main(){
    int n;
    string alu;
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        cin>>alu;
        st.insert(alu);
    }

    int m,cnt=0;
    int tmpbirth,minbirth=20200208,minbirthback=20200208;
    string sbirth,backstr;
    
    
    scanf("%d",&m);
    for(int i=0;i<m;i++){
        cin>>alu;
        if(st.find(alu)!=st.end()){
            cnt++;
            sbirth=alu.substr(6,8);
            tmpbirth=atoi(sbirth.c_str());
            mp[alu]=tmpbirth;
            if(tmpbirth<minbirth)
                minbirth=tmpbirth;
        }
        else{
            sbirth=alu.substr(6,8);
            tmpbirth=atoi(sbirth.c_str());
            if(tmpbirth<minbirthback){
                backstr=alu;
                minbirthback=tmpbirth;
            }
        }
        
    }

    string ans;
    map<string,int>::iterator it;
    for(it=mp.begin();it!=mp.end();it++){
        if(it->second==minbirth){
            ans=it->first;
            break;
        }
    }
    if(st.size()!=0)
        cout<<cnt<<endl<<ans<<endl;
    else{
        cout<<cnt<<endl<<backstr<<endl;
    }
    return 0;
}
```
### 7-3 Telefraud Detection (25分)
```
#include <bits/stdc++.h>

using namespace std;

/*题意:
如果一个

输入：
K，短电话阈值，
N，不同电话号码数
M，电话记录

duration 不超过1440分钟

输出：
按照升序打印团活中的ID

如果没有打印None


*/

int e[1010][1010];
int k,n,m;
vector<int> sus,gang;///记录团或

bool vis[1010];

void dfs(int x){
    vis[x]=true;gang.push_back(x);
    for(int i=0;i<(int)sus.size();i++){
        if(vis[sus[i]]==false&&e[x][sus[i]]>0&&e[sus[i]][x]>0)
            dfs(sus[i]);
    }
}

int main(){
    int a,b,c;
    scanf("%d%d%d",&k,&n,&m);
    memset(e,0,sizeof(e));

    for(int i=0;i<m;i++){
        scanf("%d%d%d",&a,&b,&c);
        e[a][b]+=c;
    }

    for(int i=1;i<=n;i++){
        int cnt=0,x=0;
        for(int j=1;j<=n;j++){
            if(e[i][j]<=5&&e[i][j]>0){
                cnt++;
                if(e[j][i]>0)    x++;
            }
        }
        if(cnt>k&&5*x<=cnt) sus.push_back(i);
    }



    //for(int i=0;i<(int)sus.size();i++){
    //    printf("%d ",sus[i]);

    //}
    if(sus.size()==0){
        printf("None\n");
        return 0;
    }
    memset(vis,false,sizeof(vis));
    for(int i=0;i<(int)sus.size();i++){
        if(vis[sus[i]]==false){
            gang.clear();
            dfs(sus[i]);
            sort(gang.begin(),gang.end());
            for(int i=0;i<(int)gang.size();i++){
                printf("%d",gang[i]);
                if(i<(int)gang.size()-1)
                    printf(" ");
            }
            printf("\n");
        }
    }


    return 0;
}
```
### 7-4 Structure of a Binary Tree (30分)
```
#include <bits/stdc++.h>

using namespace std;

const int maxn=40;

struct node {
	int data;
	node* lchild;
	node* rchild;
//	node(int v):data(v),lchild(NULL),rchild(NULL){}
//	如果加上这句的话，后面建立根节点要用
//	node* root = new node(pre[preL]);
};

int in[maxn], post[maxn];
int n,m,cur;
node* create(int inL, int inR,int postL, int postR) {
	if (postL > postR)
		return NULL;
	node* root = new node;
	root->data = post[postR];
	int k;
	for (k = inL; k <= inR; k++) {
		if (in[k] == post[postR])
			break;
	}
	int numLeft = k - inL;
	root->lchild = create(inL, k - 1, postL , postL + numLeft - 1);
	root->rchild = create(k + 1, inR, postL + numLeft , postR-1);
	return root;
}

void inorder(node *root){
    if(root==NULL)
        return;

    inorder(root->lchild);
    printf("%d ",root->data);
    inorder(root->rchild);
}

string sroot="root";
string siblings="siblings";
string parent="parent";
string leftchild="left";
string rightchild="right";
string level="level";
string full="full";
int anum,bnum;
bool flag;

void issiblings(node *root){
    if(root==NULL)
        return ;
    if(root->lchild!=NULL&&root->rchild!=NULL){
        if((root->lchild->data==anum&&root->rchild->data==bnum)||
           (root->lchild->data==bnum&&root->rchild->data==anum)){
           flag=true;
        }
    }
    issiblings(root->lchild);
    issiblings(root->rchild);
}

void isparent(node *root){
    if(root==NULL)
        return ;
    if(root->lchild!=NULL){
        if(root->data==anum&&root->lchild->data==bnum){
            flag=true;
            return ;
        }
        isparent(root->lchild);
    }
    if(root->rchild!=NULL){
        if(root->data==anum&&root->rchild->data==bnum){
            flag=true;
            return;
        }
        isparent(root->rchild);
    }
}

void isleftchild(node *root){
    if(root==NULL)
        return ;
    if(root->lchild!=NULL){
        if(root->data==bnum&&root->lchild->data==anum){
            flag=true;
            return ;
        }
    }
    isleftchild(root->lchild);
    isleftchild(root->rchild);
}

void isrightchild(node *root){
    if(root==NULL)
        return ;
    if(root->rchild!=NULL){
        if(root->data==bnum&&root->rchild->data==anum){
            flag=true;
            return ;
        }
    }
    isrightchild(root->lchild);
    isrightchild(root->rchild);
}

int adepth,bdepth;

void countHeight(node *root,int depth){
    if(root==NULL)
        return ;
    if(root->data==anum)
        adepth=depth;
    if(root->data==bnum)
        bdepth=depth;
    countHeight(root->lchild,depth+1);
    countHeight(root->rchild,depth+1);
}

void isfulltree(node *root){
    if(root==NULL)
        return ;
    if((root->lchild==NULL&&root->rchild!=NULL)||(root->lchild!=NULL&&root->rchild==NULL))
        flag=false;
    isfulltree(root->lchild);
    isfulltree(root->rchild);
}

int main(){
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        scanf("%d",&post[i]);
    }
    for(int i=0;i<n;i++){
        scanf("%d",&in[i]);
    }

    node* root = create(0, n - 1, 0, n - 1);
    node* tmp=root;

    string line;
    //inorder(root);
    scanf("%d",&m);
    getchar();
    for(int i=0;i<m;i++){
        getline(cin,line);
        if(line.find(sroot)!=string::npos){
            int rindex=0;
            for(int i=0;i<(int)line.size();i++){
                if(isdigit(line[i])){
                    rindex=rindex*10+(line[i]-'0');
                }
            }
            if(rindex==post[n-1]){
                printf("Yes\n");
            }
            else
                printf("No\n");
        }
        else if(line.find(level)!=string::npos){
            int i;
            anum=0,bnum=0;
            flag=false;
            for(i=0;i<(int)line.size();i++){
                if(isdigit(line[i])){
                    anum=anum*10+(line[i]-'0');
                }else
                    break;
            }
            for(int j=i+1;j<(int)line.size();j++){
                if(isdigit(line[j])){
                    bnum=bnum*10+(line[j]-'0');
                }
            }
            adepth=0,bdepth=0;
            countHeight(root,0);
            //cout<<anum<<" "<<bnum<<endl;
            if(adepth==bdepth)
                printf("Yes\n");
            else
                printf("No\n");
        }
        else if(line.find(full)!=string::npos){
            flag=true;
            isfulltree(root);///如果不判断满二叉树，可以拿到17分
            //cout<<anum<<" "<<bnum<<endl;
            if(flag)
                printf("Yes\n");
            else
                printf("No\n");
        }

        else{
            int i;
            anum=0,bnum=0;
            flag=false;
            for(i=0;i<(int)line.size();i++){
                if(isdigit(line[i])){
                    anum=anum*10+(line[i]-'0');
                }else
                    break;
            }
            for(int j=i+1;j<(int)line.size();j++){
                if(isdigit(line[j])){
                    bnum=bnum*10+(line[j]-'0');
                }
            }
            if(line.find(siblings)!=string::npos)
            //cout<<anum<<" "<<bnum<<endl;
                issiblings(root);
            if(line.find(parent)!=string::npos)
                isparent(root);
            if(line.find(leftchild)!=string::npos)
                isleftchild(root);
            if(line.find(rightchild)!=string::npos)
                isrightchild(root);
            if(flag)
                printf("Yes\n");
            else
                printf("No\n");
        }


        root=tmp;
    }

    return 0;
}
```
