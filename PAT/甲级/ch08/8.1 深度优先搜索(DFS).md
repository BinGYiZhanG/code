### 问题 A: 【递归入门】全排列 

```
#include <bits/stdc++.h>

using namespace std;

int num[30];
bool book[30];
int n;

void dfs(int step){
    int i;
    if(step==n+1){
        for(i=1;i<=n;i++)
            printf("%d ",num[i]);
        printf("\n");
        return;
    }
    for(i=1;i<=n;i++){
        if(book[i]==0){
            num[step]=i;
            book[i]=true;
            dfs(step+1);
            book[i]=false;
        }
    }
    return;
}

int main(){
    while(scanf("%d",&n)!=EOF){
        dfs(1);
    }
    return 0;
}

```

### 问题 B: 【递归入门】组合的输出 

```
#include <bits/stdc++.h>

using namespace std;

int num[30];
bool book[30];
int n,r;

void dfs(int x,int step){
    int i;
    if(step==r+1){
        for(i=1;i<=r;i++)
            printf("%d ",num[i]);
        printf("\n");
        return;
    }
    for(i=x;i<=n;i++){
        if(book[i]==0){
            num[step]=i;
            book[i]=true;
            dfs(i,step+1);
            book[i]=false;
        }
    }
    return;
}

int main(){
    while(scanf("%d%d",&n,&r)!=EOF){
        dfs(1,1);
    }
    return 0;
}
```

#### 组合和排列的不同，组合需要多加一个```x```，而排列无需多加



### 问题 C: 【递归入门】组合+判断素数

```
#include <bits/stdc++.h>

using namespace std;

int num[25];///存储读入的n个整数,因为x最大为50000000,所以要用长整型存储
int n,r;///数字个数n,选择k个整数
int cnt=0;///记录满足条件的方案数
int sum=0;
bool isPrime(int x){
    if(x<=1)    return false;
    int Sqr=(int)sqrt(x*1.0);
    for(int i=2;i<=Sqr;i++){
        if(x%i==0){
            return false;
        }
    }
    return true;
}

void DFS(int index,int level){
    if(level==r){
        if(isPrime(sum))
            cnt++;
        return ;
    }
    for(int i=index;i<n;i++){
        sum+=num[i];
        DFS(i+1,level+1);///不是index+1,而是i+1,因为要遍历num数组,
        sum-=num[i];
    }
}

int main()
{
    while(scanf("%d%d",&n,&r)!=EOF){
        cnt=0;
        sum=0;
        for(int i=0;i<n;i++)
            scanf("%d",&num[i]);
        DFS(0,0);///第一个0，代表取num数组的编号,
                ///第二个0,代表sum中num数组的编号
        printf("%d\n",cnt);
    }

    return 0;
}
```

### 问题 D: 【递归入门】n皇后 问题（原始的8皇后问题）

* [参考样例：问题 D: 八皇后](https://blog.csdn.net/wchzh2015/article/details/102810936)

```
#include<bits/stdc++.h>

using namespace std;

int n;

vector<int> ans;
vector<vector<int> > num;
vector<bool> visit(12,0);

void generateP(int index){
    if(index==n){
        bool flag=true;
        for(int i=0;i<n;i++)
            for(int j=i+1;j<n;j++)
            if(abs(i-j)==abs(ans[i]-ans[j]))
                flag=false;
        //for(int i=0;i<ans.size();i++)
        //    printf("%d ",ans[i]);
        //printf("%d\n",flag);
        if(flag==true)
            num.push_back(ans);
        return ;
    }
    for(int i=0;i<n;i++){
        if(visit[i]==0){
            ans.push_back(i+1);
            visit[i]=1;
            generateP(index+1);
            visit[i]=0;
            ans.pop_back();
        }
    }
}

int cnt;

int main(){
    while(scanf("%d",&n)!=EOF){
        generateP(0);
        cnt=0;
        for(int i=0;i<(int)num.size();++i){
            for(int j=0;j<(int)num[i].size();j++){
                printf("%d",num[i][j]);
                if(j<(int)num[i].size()-1)
                    printf(" ");
            }
            cnt++;
            printf("\n");
        }
        if(cnt==0)  printf("no solute!\n");
    }
    return 0;
}
```



### 问题 F: 【递归入门】走迷宫



```
#include <bits/stdc++.h>

using namespace std;

int a[20][20],endx,endy,m,n;
bool no=true;
int dx[4]={0,-1,0,1},dy[4]={-1,0,1,0};

struct Route{
    int x,y;
}route[5010];

void DFS(int x,int y,int num){
    if(x==endx&&y==endy){///如果到达终点
        for(int i=0;i<num;i++)
            printf("(%d,%d)->",route[i].x,route[i].y);
        printf("(%d,%d)\n",x,y);
        no=false;
        return ;
    }
    route[num].x=x,route[num].y=y;
    for(int i=0;i<4;i++){
        if(x+dx[i]>=1&&x+dx[i]<=m&&1<=y+dy[i]&&y+dy[i]<=n&&a[x+dx[i]][y+dy[i]]==1){
            a[x][y]=0;///路走过之后，置为0,不可行
            DFS(x+dx[i],y+dy[i],num+1);
            a[x][y]=1;
        }
    }
}

int main(){
    while(scanf("%d%d",&m,&n)!=EOF){
        for(int i=1;i<=m;i++)
            for(int j=1;j<=n;j++)
                scanf("%d",&a[i][j]);
        int stx,sty;
        scanf("%d%d%d%d",&stx,&sty,&endx,&endy);
        DFS(stx,sty,0);
        if(no)  printf("-1\n");
    }

    return 0;
}


```

