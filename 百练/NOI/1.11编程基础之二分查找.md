## 01:查找最接近的元素

* ```TLE```代码

```
#include <bits/stdc++.h>

using namespace std;

int a[100010];

struct Node{
    int num,minu;
}node[100010];

bool cmp(const Node a,const Node b){
    return a.minu<b.minu;
}

int main(){
    int n,m,tmp;
    scanf("%d",&n);
    for(int i=0;i<n;i++)    scanf("%d",&node[i].num);
    scanf("%d",&m);
    for(int i=0;i<m;i++){
        scanf("%d",&tmp);
        for(int i=0;i<n;i++)
            node[i].minu=abs(node[i].num-tmp);
        sort(node,node+n,cmp);
        cout<<node[0].num<<endl;
    }
    return 0;
}
```

* ```AC```代码
```
#include <bits/stdc++.h>

using namespace std;

int a[100010];


int main(){
    int n,m,tmp;
    scanf("%d",&n);
    for(int i=0;i<n;i++)    scanf("%d",a+i);
    scanf("%d",&m);
    for(int i=0;i<m;i++){
        scanf("%d",&tmp);
        int j=lower_bound(a,a+n,tmp) - a;///输入10 返回3
        if(j==n){///说明不存在大于等于tmp的数，也就是都小于,
            cout<<a[j-1]<<endl;
        }
        else{
            if(j>0){
                if(abs(a[j]-tmp)>abs(a[j-1]-tmp))
                    cout<<a[j-1]<<endl;
                else if(abs(a[j]-tmp)<abs(a[j-1]-tmp))
                    cout<<a[j]<<endl;
                else
                    cout<<a[j-1]<<endl;///若有多个值满足条件，输出最小的一个。
            }
            else
                cout<<a[j]<<endl;
        }

    }
    return 0;
}

```
### 利用自己写的二分来构建

## 02:二分法求函数的零点

* ```AC代码```
```
#include <bits/stdc++.h>

using namespace std;

double result(double x){
    return pow(x,5)-15*pow(x,4)+85*pow(x,3)-225*pow(x,2)+274*x-121;
}

int main(){
    double st=1.5,ed=2.4;
    double mid;

    while(ed-st>0.00000001){
        mid=(ed-st)/2+st;
        if(result(mid)==0.0)
            break;
        else if(result(mid)*result(st)<0)
            ed=mid;
        //写成这样，错误：else if(result(mid)*result(ed)<0)///有根存在
        else
            st=mid;
    }

    printf("%.6lf",mid);
    return 0;
}
```
* [转自CSDN](https://blog.csdn.net/mayuan2017/article/details/78534427)
  * 
```
#include <iostream>
#include <iomanip>
#include <cmath>
using namespace std;
bool check(double mid)
{
    double f = pow(mid,5)-15.0*pow(mid,4)+85.0*pow(mid,3)-225.0*pow(mid,2)+274.0*mid-121.0;
    if(f > 0.0) return 1;
    return 0;
}
int main()
{
    double l=1.5, r=2.4, mid;
    while(r-l > 0.00000001){
        mid = (l+r)/2.0;
        if (check(mid)) l = mid;
        else r = mid;
    }
    cout << fixed << setprecision(6) << mid << endl;
    return 0;
}
```

## 03:矩形分割





















