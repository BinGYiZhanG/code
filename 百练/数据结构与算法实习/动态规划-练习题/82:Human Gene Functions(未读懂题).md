### 描述
* 一个人的基因被考虑成一个序列，包含4种，简单地用字母来代替，A,C,G,T
* 生物学家对识别基因感兴趣并且决定研究一下他们的作用，因为只可以诊断人类疾病并且为他们设计药物

* 一个人的基因被识别为一串数，在电脑程序的帮助下。一旦一个基因序列被得到，下一个工作就是决定他的功能

* 生物学家的方法之一就是查询一个基因库，这个库被搜索存储基因序列和他们的作用,许多研究者提交他们的基因和功能到这个数据库并且数据库在网上可以免费获得
* 一个数据库搜索将从数据库中得到一系列和查询相似基因序列,生物学家假定序列相似性经常暗含着功能相似性
* 所以，新基因的功能或许是从表单基因的功能之一。准确的说，决定一个序列的功能是否安排正确，要靠实验来决定

* 你的工作是写一个程序来比较两段基因按照下列规则决定他们的相似性,你的代码应该被用来作为数据库的一部分如果你提供的是高效的程序的话
* 给出两段基因AGTGATG和GTTAG，它俩有多相似？一种检测两段基因相似性的方法叫做对齐
* 在一个对齐下，空格将被插入，如果有必要，使它们相同的部分更长并且根据得分矩阵对结果基因进行打分
根据这张表进行字符串匹配：
![](https://github.com/xiean927/code/blob/master/Image/%E6%89%B9%E6%B3%A8%202020-01-24%20092247.png)

* 例如，
```
1 2 3 4 5 6 7 8 9
A G T G A T - G
- G T - - T A G 

(-3)+5+5+(-2)+(-3)+5+(-3)+5=9. 
```
### 题意
* 给出两个只包含字母ACGT的字符串s1、s2，可以在两个字符串中插入字符“-”，使得s1与s2的相似度最大。

### 思路：
* 动态规划（一开始连题都未读懂...)
* 求两个串匹配的最大权值，dp[i][j]表示分别为i,j的两个串的进行匹配的最大值。
* 每个字符可以选择和空格匹配或者和非空格匹配，
* 当i=0或j=0时，就等于是在长度等于0的字符串中全部插入“-”，使得两字符串长度相等的相似度。
```
dp[i][j]=max(dp[i-1][j-1]+v[i][j],dp[i-1][j]+v[i][kong],dp[i][j-1]+v[kong][j]);
v[i][j]表示字符i和j匹配的权值.
```

* ```AC代码```
```
#include <bits/stdc++.h>

using namespace std;

int f[110][110],w[510][510],T,n1,n2;
char s1[110],s2[110];

int main() {
    scanf("%d",&T);
    w['A']['A']=5;w['A']['C']=-1;w['A']['G']=-2;w['A']['T']=-1;w['A']['-']=-3;
    w['C']['A']=-1;w['C']['C']=5;w['C']['G']=-3;w['C']['T']=-2;w['C']['-']=-4;
    w['G']['A']=-2;w['G']['C']=-3;w['G']['G']=5;w['G']['T']=-2;w['G']['-']=-2;
    w['T']['A']=-1;w['T']['C']=-2;w['T']['G']=-2;w['T']['T']=5;w['T']['-']=-1;
    w['-']['A']=-3;w['-']['C']=-4;w['-']['G']=-2;w['-']['T']=-1;w['-']['-']=0;
    while (T--) {
        memset(f,0,sizeof(f));
        scanf("%d%s%d%s",&n1,s1+1,&n2,s2+1);
        f[0][0]=0;
        for (int i=0;i<=n1;i++) ///一个dp[i][0]长度为i的字符串和空串匹配的最大值
            f[i][0]=w[s1[i]]['-']+f[i-1][0];
        for (int i=0;i<=n2;i++) ///一个dp[0][i]长度为i的字符串和空串匹配的最大值
            f[0][i]=w['-'][s2[i]]+f[0][i-1];
        for (int i=1;i<=n1;i++)
            for (int j=1;j<=n2;j++) {
                f[i][j]=f[i-1][j-1]+w[s1[i]][s2[j]];
                f[i][j]=max(f[i][j],f[i-1][j]+w[s1[i]]['-']);///选择和空格匹配，还是和非空格匹配
                f[i][j]=max(f[i][j],f[i][j-1]+w['-'][s2[j]]);///
            }
        printf("%d\n",f[n1][n2]);
    }
    return 0;
}
```

